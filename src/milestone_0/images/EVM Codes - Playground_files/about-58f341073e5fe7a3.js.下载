(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[521],{69264:function(e,t,s){"use strict";s.d(t,{Z:function(){return P}});var r=s(3610),n=s.n(r),a=s(70416),o=s(79617),i=s(48004),c=s(57410);var l=()=>(0,c.jsx)("footer",{className:"border-t border-gray-100 dark:border-black-600 py-4",children:(0,c.jsx)(i.W,{children:(0,c.jsxs)("div",{className:"flex justify-between text-tiny text-gray-500 items-start",children:[(0,c.jsxs)("div",{className:"flex flex-col md:flex-row leading-6",children:[(0,c.jsxs)("span",{children:["Brought to you by"," ",(0,c.jsx)("a",{className:"underline font-medium",href:"https://smlxl.io",target:"_blank",rel:"noreferrer",children:"smlXL, Inc"}),"."]}),(0,c.jsxs)("span",{className:"md:mx-2",children:["Powered by"," ",(0,c.jsx)("a",{className:"underline font-medium",href:"https://github.com/ethereumjs/ethereumjs-monorepo",target:"_blank",rel:"noreferrer",children:"EthereumJS"})," ","and"," ",(0,c.jsx)("a",{className:"underline font-medium",href:"https://github.com/ethereum/solc-js",target:"_blank",rel:"noreferrer",children:"SolcJS"}),"."]})]}),(0,c.jsx)("div",{children:(0,c.jsx)("a",{className:"underline",href:o.Vh,target:"_blank",rel:"noreferrer",children:"GitHub"})})]})})}),h=s(36765),d=s(73752),m=s.n(d),u=s(41262),x=s.n(u),f=s(76747),p=s(79176);var j=()=>{const{query:e}=(0,f.useKBar)();return(0,c.jsxs)(p.zx,{size:"xs",onClick:e.toggle,className:"mx-4 py-1 px-2 font-medium",transparent:!0,outline:!0,padded:!1,children:[a.V&&(0,c.jsx)(p.JO,{name:"command-line",className:"mr-1"}),a.V?(0,c.jsx)("span",{children:"K"}):(0,c.jsx)("span",{children:"Ctrl + K"})]})};var b=e=>{let{href:t,children:s,className:r,external:n=!1}=e;return(0,c.jsx)("li",{className:m()("inline-block mx-4 text-sm my-2 md:my-0 text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white",r),children:(0,c.jsx)(x(),{legacyBehavior:!0,href:t,passHref:n,children:(0,c.jsx)("a",{target:n?"_blank":"_self",children:s})})})},g=s(11495);var y=()=>{const{theme:e,setTheme:t,resolvedTheme:s}=(0,g.F)(),r=[{id:"theme",name:"Select theme\u2026",shortcut:["t"],keywords:"theme appearance",section:"Preferences"},{id:"theme-light",name:"Light",shortcut:[],keywords:"light",section:"",perform:()=>t("light"),parent:"theme"},{id:"theme-dark",name:"Dark",shortcut:[],keywords:"dark",section:"",perform:()=>t("dark"),parent:"theme"},{id:"theme-system",name:"System",shortcut:[],keywords:"system",section:"",perform:()=>t("system"),parent:"theme"}];(0,f.useRegisterActions)(r,[r]);return(0,c.jsx)(p.zx,{transparent:!0,onClick:()=>{t("dark"===e?"light":"dark")},children:(0,c.jsx)(p.JO,{name:"dark"===s?"contrast-2-fill":"contrast-2-line",className:"text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white"})})},w=s(70129),C=s(29713),k=s(43836),v=s(12038),E=s(9815),N=s(86569);function T(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,r)}return s}function A(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?T(Object(s),!0).forEach((function(t){(0,w.Z)(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):T(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}const O=e=>{const{data:t,label:s}=e,r=t.value===o.h_;return(0,c.jsxs)(k.c.Option,A(A({},e),{},{children:[s,r&&(0,c.jsx)(p.__,{children:"Live"})]}))};var S=()=>{const{forks:e,selectedFork:t,onForkChange:s}=(0,h.useContext)(E.DB),{0:r,1:n}=(0,h.useState)(),{0:a,1:i}=(0,h.useState)([]),l=(0,C.useRouter)(),d=(0,h.useMemo)((()=>e.map((e=>({value:e.name,label:e.name})))),[e]),m=(0,h.useMemo)((()=>d.find((e=>e.value===(null===t||void 0===t?void 0:t.name)))),[d,t]),u=(0,h.useCallback)((e=>{n(e),s(e.value),l.query.fork=e.value,l.push({query:l.query})}),[s]);return(0,h.useEffect)((()=>{if(!l.isReady)return;const e=l.query.fork?d.find((e=>e.value===l.query.fork)):d.find((e=>e.value===o.h_));e&&n(e)}),[l.isReady,m]),(0,h.useEffect)((()=>{const e=[],t=d.map(((t,s)=>{const r=(0,N.GT)("fork",s);return e.push(r),{id:r,name:t.label,shortcut:[],keywords:t.label,section:"",perform:()=>u(t),parent:"fork"}}));e.length>0&&i([{id:"fork",name:"Select hardfork\u2026",shortcut:["f"],keywords:"fork network evm",section:"Preferences"},...t])}),[d,u]),(0,f.useRegisterActions)(a,[a]),(0,c.jsx)("div",{className:"flex justify-end items-center rounded",children:e.length>0&&(0,c.jsxs)("div",{className:"flex items-center mr-2",children:[(0,c.jsx)(p.JO,{name:"git-branch-line",className:"text-indigo-500 mr-2"}),(0,c.jsx)(v.ZP,{onChange:u,options:d,value:r,isSearchable:!1,classNamePrefix:"select",menuPlacement:"auto",components:{Option:O}})]})})};var _=()=>{const{0:e,1:t}=(0,h.useState)(!1);return(0,c.jsx)("nav",{className:"fixed z-40 top-0 inset-x-0 py-2 bg-white dark:bg-black-800",children:(0,c.jsx)(p.W2,{children:(0,c.jsxs)("div",{className:"h-10 flex items-center justify-between",children:[(0,c.jsx)(x(),{legacyBehavior:!0,href:"/",passHref:!0,children:(0,c.jsx)("a",{children:(0,c.jsx)(p.TR,{})})}),(0,c.jsxs)("ul",{className:m()("py-2 md:py-0 px-2 flex justify-between items-start md:items-center flex-col md:flex-row w-full md:w-auto fixed md:static shadow-md md:shadow-none transition-all",{"left-0 bg-white dark:bg-black-800 md:bg-transparent dark:md:bg-transparent":e,"-left-full":!e}),style:{top:56},children:[(0,c.jsx)(b,{href:"/",children:"Opcodes"}),(0,c.jsx)(b,{href:"/precompiled",children:"Precompiled Contracts"}),(0,c.jsx)(b,{href:"/contract",children:"Contract Viewer"}),(0,c.jsx)(b,{href:"/playground",children:"Playground"}),(0,c.jsx)(b,{href:"/about",children:"About the EVM"}),(0,c.jsx)(b,{href:o.Vh,external:!0,children:"GitHub"}),(0,c.jsx)("li",{className:"hidden lg:inline-block",children:(0,c.jsx)(j,{})})]}),(0,c.jsxs)("div",{className:"items-center ml-auto flex",children:[(0,c.jsx)(S,{}),(0,c.jsx)(y,{})]}),(0,c.jsx)(p.pr,{isActive:e,onClick:()=>t(!e)})]})})})};var P=e=>{let{children:t}=e;return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n(),{children:[(0,c.jsx)("title",{children:"EVM Codes - An Ethereum Virtual Machine Opcodes Interactive Reference"}),(0,c.jsx)("meta",{property:"og:type",content:"website"}),(0,c.jsx)("meta",{property:"og:title",content:"EVM Codes"}),(0,c.jsx)("meta",{property:"og:description",content:"An Ethereum Virtual Machine Opcodes Interactive Reference"}),(0,c.jsx)("meta",{property:"og:image",content:`${(0,a.C)("/og.png")}`}),(0,c.jsx)("meta",{property:"og:url",content:(0,a.C)()}),(0,c.jsx)("link",{rel:"icon",href:"/favicon.ico"})]}),(0,c.jsxs)("div",{className:"flex flex-col h-screen justify-between",children:[(0,c.jsx)(_,{}),(0,c.jsx)("main",{className:"mb-auto mt-20 md:mt-28 pb-10",children:t}),(0,c.jsx)(l,{})]})]})}},54021:function(e,t,s){"use strict";s.d(t,{A:function(){return g},H1:function(){return l},H2:function(){return h},H3:function(){return d},LI:function(){return f},OL:function(){return x},P:function(){return m},S:function(){return y},TD:function(){return b},TH:function(){return j},UL:function(){return u},i:function(){return p}});var r=s(73752),n=s.n(r),a=s(41262),o=s.n(a),i=s(57410);const c="*",l=e=>{let{children:t}=e;return(0,i.jsx)("h1",{className:"text-lg font-semibold my-4",children:t})},h=e=>{let{children:t}=e;return(0,i.jsx)("h2",{className:"text-base font-semibold my-4",children:t})},d=e=>{let{children:t}=e;return(0,i.jsx)("h2",{className:"text-sm font-medium my-3",children:t})},m=e=>{let{children:t}=e;return(0,i.jsx)("p",{className:"leading-5 mb-4",children:t})},u=e=>{let{children:t}=e;return(0,i.jsx)("ul",{className:"list-disc mb-2",children:t})},x=e=>{let{children:t}=e;return(0,i.jsx)("ol",{className:"list-decimal mb-4",children:t})},f=e=>{let{children:t}=e;return(0,i.jsx)("li",{className:"ml-6",children:t})},p=e=>{let{children:t}=e;return(0,i.jsx)("table",{className:"table-auto mb-4",children:t})},j=e=>{let{children:t}=e;return(0,i.jsx)("th",{className:n()("py-1 px-2 border-indigo-200 dark:border-black-400 text-gray-800 dark:text-gray-400 text-tiny font-medium break-all",{border:t!==c}),children:t!==c&&t})},b=e=>{let{children:t}=e;return(0,i.jsx)("td",{className:n()("py-1 px-2 border-indigo-200 dark:border-black-400 text-tiny font-normal break-all",{border:t!==c}),children:t!==c&&t})},g=e=>{let{children:t,href:s}=e;return(0,i.jsx)(o(),{legacyBehavior:!0,href:s,scroll:!1,children:(0,i.jsx)("a",{className:"underline",children:t})})},y=e=>{let{children:t}=e;return(0,i.jsx)("div",{children:(0,i.jsx)("pre",{className:"text-tiny inline-block whitespace-pre-wrap p-5 mb-4 bg-indigo-100 dark:bg-gray-800 rounded",children:t})})}},8768:function(e,t,s){"use strict";s.r(t);var r=s(36765),n=s(3610),a=s.n(n),o=s(41262),i=s.n(o),c=s(69264),l=s(79176),h=s(54021),d=s(57410);const m=e=>{let{header:t,anchorKey:s,children:n}=e;return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(r.Fragment,{children:[(0,d.jsx)(a(),{children:(0,d.jsx)("title",{children:" EVM Codes - About the EVM "})}),(0,d.jsx)("meta",{property:"og:description",content:"How does the EVM work? We explain the relationship between opcode instructions, gas costs, storage and the execution environment for your understanding."})]}),(0,d.jsxs)("div",{id:s,className:"font-mono mb-4 justify-start relative items-center scroll-mt-14",children:[(0,d.jsx)(i(),{legacyBehavior:!0,href:`/about#${s}`,children:(0,d.jsx)("a",{className:"absolute -left-6",children:(0,d.jsx)(l.JO,{name:"links-line",className:"text-indigo-500"})})}),t]}),(0,d.jsx)("div",{children:n})]})},u=()=>(0,d.jsxs)(l.W2,{className:"text-sm leading-6 max-w-4xl",children:[(0,d.jsx)(l.H1,{children:"About the EVM"}),(0,d.jsxs)(m,{header:(0,d.jsx)(l.H2,{children:"Introduction"}),anchorKey:"introduction",children:[(0,d.jsxs)("p",{className:"pb-6",children:[(0,d.jsx)(l.H3,{children:"What is the Ethereum Virtual Machine?"}),"The Ethereum Virtual Machine (or"," ",(0,d.jsx)("a",{href:"https://ethereum.org/en/developers/docs/evm/",target:"_blank",rel:"noreferrer",className:"underline",children:"EVM"}),") is a stack-based computer, responsible for the execution of smart contract instructions. All EVM instructions take their parameter from the stack, except for ",(0,d.jsx)(l.Ch,{to:"#60",title:"PUSHx"}),", which takes their parameters from the code. Each instruction has stack inputs, the parameters that they may need, and stack outputs (their return values). The list of these instructions, with their opcodes, is accessible in our ",(0,d.jsx)(l.Ch,{title:"reference"}),"."]}),(0,d.jsxs)("p",{className:"pb-8",children:[(0,d.jsx)(l.H3,{children:"What is a smart contract?"}),"A smart contract is a set of instructions. Each instruction is an opcode (with their own handy mnemonic for reference, text representations of their assigned values between 0 and 255). When the EVM executes a smart contract, it reads and executes each instruction sequentially, except for"," ",(0,d.jsx)(l.Ch,{to:"#56",title:"JUMP"})," and"," ",(0,d.jsx)(l.Ch,{to:"#57",title:"JUMPI"})," instructions. If an instruction cannot be executed (e.g. when there is insufficient gas or not enough values on the stack), the execution reverts. Transaction reversion can also be triggered with the"," ",(0,d.jsx)(l.Ch,{to:"#FD",title:"REVERT"})," opcode (which refunds the unused gas fees of its call context, in contrast to all of the gas being consumed in all the other cases of reversion). In the event of a reverted transaction, any state changes dictated by the transaction instructions are returned to their state before the transaction."]})]}),(0,d.jsx)(m,{header:(0,d.jsx)(l.H2,{children:"Execution Environment"}),anchorKey:"executionenv",children:(0,d.jsx)("p",{className:"pb-8",children:"When the EVM executes a smart contract, a context is created for it. This context is made of several data regions, each with a distinct purpose, as well as variables, such as the program counter, the current caller, the callee and the address of the current code."})}),(0,d.jsx)(m,{header:(0,d.jsx)(l.H3,{children:"The Code"}),anchorKey:"code",children:(0,d.jsxs)("p",{className:"pb-8",children:["The code is the region where instructions are stored. Instruction data stored in the code is persistent as part of a contract account state field. Externally owned accounts (or EOAs) have empty code regions. Code is the bytes read, interpreted, and executed by the EVM during smart contract execution. Code is immutable, which means it cannot be modified, but it can be read with the instructions"," ",(0,d.jsx)(l.Ch,{to:"#38",title:"CODESIZE"})," and"," ",(0,d.jsx)(l.Ch,{to:"#39",title:"CODECOPY"}),". The code of one contract can be read by other contracts, with instructions"," ",(0,d.jsx)(l.Ch,{to:"#3B",title:"EXTCODESIZE"})," and"," ",(0,d.jsx)(l.Ch,{to:"#3C",title:"EXTCODECOPY"}),"."]})}),(0,d.jsx)(m,{header:(0,d.jsx)(l.H3,{children:"The Program Counter"}),anchorKey:"counter",children:(0,d.jsxs)("p",{className:"pb-8",children:["The Program Counter (PC) encodes which instruction, stored in the code, should be next read by the EVM. The program counter is usually incremented by one byte, to point to the following instruction, with some exceptions. For instance, the"," ",(0,d.jsx)(l.Ch,{to:"#60",title:"PUSHx"})," instruction is longer than a single byte, and causes the PC to skip their parameter. The"," ",(0,d.jsx)(l.Ch,{to:"#56",title:"JUMP"})," instruction does not increase the PC's value, instead, it modifies the program counter to a position specified by the top of the stack."," ",(0,d.jsx)(l.Ch,{to:"#57",title:"JUMPI"})," does this as well, if its condition is true (a nonzero code value), otherwise, it increments the PC like other instructions."]})}),(0,d.jsx)(m,{header:(0,d.jsx)(l.H3,{children:"The Stack"}),anchorKey:"stack",children:(0,d.jsxs)("p",{className:"pb-8",children:["The stack is a list of 32-byte elements used to store smart contract instruction inputs and outputs. There is one stack created per call context, and it is destroyed when the call context ends. When a new value is put on the stack, it is put on top, and only the top values are used by the instructions. The stack currently has a maximum limit of 1024 values. All instructions interact with the stack, but it can be directly manipulated with instructions like"," ",(0,d.jsx)(l.Ch,{to:"#60",title:"PUSH1"}),","," ",(0,d.jsx)(l.Ch,{to:"#50",title:"POP"}),","," ",(0,d.jsx)(l.Ch,{to:"#80",title:"DUP1"}),", or"," ",(0,d.jsx)(l.Ch,{to:"#90",title:"SWAP1"}),"."]})}),(0,d.jsx)(m,{header:(0,d.jsx)(l.H3,{children:"The Memory"}),anchorKey:"memory",children:(0,d.jsxs)("p",{className:"pb-8",children:["EVM memory is not persistent and is destroyed at the end of the call context. At the start of a call context, memory is initialized to 0. Reading and Writing from memory is usually done with"," ",(0,d.jsx)(l.Ch,{to:"#51",title:"MLOAD"})," and"," ",(0,d.jsx)(l.Ch,{to:"#52",title:"MSTORE"})," instructions respectively, but can also be accessed by other instructions like"," ",(0,d.jsx)(l.Ch,{to:"#F0",title:"CREATE"})," or"," ",(0,d.jsx)(l.Ch,{to:"#F3",title:"EXTCODECOPY"}),". We discuss"," ",(0,d.jsx)(l.Ch,{to:"about#memoryexpansion",title:"memory size calculations"})," ","later in this document."]})}),(0,d.jsx)(m,{header:(0,d.jsx)(l.H3,{children:"The Storage"}),anchorKey:"storage",children:(0,d.jsxs)("p",{className:"pb-8",children:["Storage is a map of 32-byte slots to 32-byte values. Storage is the persistent memory of smart contracts: each value written by the contract is retained past the completion of a call, unless its value is changed to 0, or the ",(0,d.jsx)(l.Ch,{to:"#FF",title:"SELFDESTRUCT"})," ","instruction is executed. Reading stored bytes from an unwritten key also returns 0. Each contract has its own storage, and cannot read or modify storage from another contract. Storage is read and written with instructions ",(0,d.jsx)(l.Ch,{to:"#54",title:"SLOAD"})," and"," ",(0,d.jsx)(l.Ch,{to:"#55",title:"SSTORE"}),"."]})}),(0,d.jsx)(m,{header:(0,d.jsx)(l.H3,{children:"The calldata"}),anchorKey:"calldata",children:(0,d.jsxs)("p",{className:"pb-8",children:["The calldata region is the data sent to a transaction as part of a smart contract transaction. For example, when creating a contract, calldata would be the constructor code of the new contract. Calldata is immutable, and can be read with instructions"," ",(0,d.jsx)(l.Ch,{to:"#35",title:"CALLDATALOAD"}),","," ",(0,d.jsx)(l.Ch,{to:"#36",title:"CALLDATASIZE"}),", and"," ",(0,d.jsx)(l.Ch,{to:"#37",title:"CALLDATACOPY"}),". It is important to note that when a contract executes an xCALL instruction, it also creates an internal transaction. As a result, when executing xCALL, there is a calldata region in the new context."]})}),(0,d.jsx)(m,{header:(0,d.jsx)(l.H3,{children:"The return data"}),anchorKey:"returndata",children:(0,d.jsxs)("p",{className:"pb-8",children:["The return data is the way a smart contract can return a value after a call. It can be set by contract calls through the"," ",(0,d.jsx)(l.Ch,{to:"#F3",title:"RETURN"})," and"," ",(0,d.jsx)(l.Ch,{to:"#FD",title:"REVERT"})," instructions, and can be read by the calling contract with"," ",(0,d.jsx)(l.Ch,{to:"#3D",title:"RETURNDATASIZE"})," and"," ",(0,d.jsx)(l.Ch,{to:"#3E",title:"RETURNDATACOPY"}),"."]})}),(0,d.jsxs)(m,{header:(0,d.jsx)(l.H2,{children:"Gas Costs"}),anchorKey:"gascosts",children:[(0,d.jsxs)("p",{className:"pb-4",children:["Each transaction on the Ethereum blockchain is vetted by a third-party validator, before it is added to the blockchain. These validators are compensated for conducting this vetting process, and adding transactions to the blockchain, with incentive fee payments. Fees vary from transaction to transaction, contingent on different variables for different forks. Some variables in calculating fees include:",(0,d.jsxs)("ul",{className:"list-disc mb-2",children:[(0,d.jsx)("br",{}),(0,d.jsxs)("li",{children:[(0,d.jsx)("b",{children:"Current price of one gas unit:"})," Gas, or gwei, is a denomination of Ethereum, used in fee payment. Gas prices vary over time, based on the current demand for block space, measured in ETH per gas."]}),(0,d.jsx)("br",{}),(0,d.jsxs)("li",{children:[(0,d.jsx)("b",{children:"Calldata size:"})," Each calldata byte costs gas, the larger the size of the transaction data, the higher the gas fees. Calldata costs 4 gas per byte equal to 0, and 16 gas for the others (64 before the hardfork Istanbul)."]}),(0,d.jsx)("br",{}),(0,d.jsxs)("li",{children:[" ",(0,d.jsx)("b",{children:"Intrinsic Gas"}),": Each transaction has an intrinsic cost of 21000 gas. Creating a contract costs 32000 gas, on top of the transaction cost. Again: calldata costs 4 gas per byte equal to 0, and 16 gas for the others (64 before the hardfork ",(0,d.jsx)("b",{children:"Istanbul"}),"). This cost is paid from the transaction before any opcode or transfer execution."]}),(0,d.jsx)("br",{}),(0,d.jsxs)("li",{children:[(0,d.jsx)("b",{children:"Opcode Fixed Execution Cost"}),": Each opcode has a fixed cost to be paid upon execution, measured in gas. This cost is the same for all executions, though this is subject to change in new hardforks. See our"," ",(0,d.jsx)("a",{href:"https://www.evm.codes/",target:"_blank",rel:"noreferrer",className:"underline",children:"reference"})," ","to learn about the specific costs per opcode and fork."]}),(0,d.jsx)("br",{}),(0,d.jsxs)("li",{children:[" ",(0,d.jsx)("b",{children:"Opcode Dynamic Execution Cost:"})," Some instructions conduct more work than others, depending on their parameters. Because of this, on top of fixed costs, some instructions have dynamic costs. These dynamic costs are dependent on several factors (which vary from hardfork to hardfork). See our"," ",(0,d.jsx)("a",{href:"https://www.evm.codes/",target:"_blank",rel:"noreferrer",className:"underline",children:"reference"})," ","to learn about the specific computations per opcode and fork."]})]})]}),(0,d.jsxs)("p",{className:"pb-8",children:["To get a complete estimation of the gas cost for your program, with your compiler options and specific state and inputs, use a tool like"," ",(0,d.jsx)("a",{href:"https://remix.ethereum.org/",target:"_blank",rel:"noreferrer",className:"underline",children:"Remix"})," ","or"," ",(0,d.jsx)("a",{href:"https://trufflesuite.com/",target:"_blank",rel:"noreferrer",className:"underline",children:"Truffle"}),"."]})]}),(0,d.jsxs)(m,{header:(0,d.jsx)(l.H3,{children:"Memory Expansion"}),anchorKey:"memoryexpansion",children:[(0,d.jsx)("p",{className:"pb-6",children:"During a smart contract execution, memory can be accessed with opcodes. When an offset is first accessed (either read or write), memory may trigger an expansion, which costs gas."}),(0,d.jsx)("p",{className:"pb-6",children:"Memory expansion may be triggered when the byte offset (modulo 32) accessed is bigger than previous offsets. If a larger offset trigger of memory expansion occurs, the cost of accessing the higher offset is computed and removed from the total gas available at the current call context."}),(0,d.jsxs)("p",{className:"pb-4",children:[(0,d.jsx)("p",{className:"pb-4",children:"The total cost for a given memory size is computed as follows:"}),(0,d.jsx)(h.S,{children:(0,d.jsxs)("code",{children:["memory_size_word = (memory_byte_size + 31) / 32",(0,d.jsx)("br",{}),"memory_cost = (memory_size_word ** 2) / 512 + (3 * memory_size_word)"]})})]}),(0,d.jsxs)("p",{className:"pb-4",children:[(0,d.jsx)("p",{className:"pb-4",children:"When a memory expansion is triggered, only the additional bytes of memory must be paid for. Therefore, the cost of memory expansion for the specific opcode is thus:"}),(0,d.jsx)(h.S,{children:(0,d.jsx)("code",{children:"memory_expansion_cost = new_memory_cost - last_memory_cost"})})]}),(0,d.jsxs)("p",{className:"pb-8",children:["The ",(0,d.jsx)("code",{children:"memory_byte_size"})," can be obtained with opcode"," ",(0,d.jsx)(l.Ch,{to:"#59",title:"MSIZE"}),". The cost of memory expansion triggered by ",(0,d.jsx)(l.Ch,{to:"#59",title:"MSIZE"})," grows quadratically, disincentivizing the overuse of memory by making higher offsets more costly. Any opcode that accesses memory may trigger an expansion (such as ",(0,d.jsx)(l.Ch,{to:"#51",title:"MLOAD"}),","," ",(0,d.jsx)(l.Ch,{to:"#F3",title:"RETURN"})," or"," ",(0,d.jsx)(l.Ch,{to:"#37",title:"CALLDATACOPY"}),"). Use our ",(0,d.jsx)(l.Ch,{title:"reference"})," to review which opcode is capable of accessing memory. Note that opcodes with a byte size parameter of 0 will not trigger memory expansion, regardless of their offset parameters."]})]}),(0,d.jsxs)(m,{header:(0,d.jsx)(l.H3,{children:"Access List"}),anchorKey:"access_list",children:[(0,d.jsx)("p",{className:"pb-6",children:"Access list is defined per external transaction, and not per call. Each transaction may be defined by some combination of its sender, calldata, or callee. Transactions can either be external or internal. External transactions are sent to the Ethereum network. Internal transactions are triggered by external transactions that have executed the xCALL instruction. As such, internal transactions are also known as calls. Access list can be thought of as two independent types of lists: those of touched addresses, and those of touched contract storage slots."}),(0,d.jsxs)("p",{className:"pb-6",children:["When an address is accessed by a transaction, instruction, or used as caller or callee, it is put in the access list. Calling the opcode"," ",(0,d.jsx)(l.Ch,{to:"#31",title:"BALANCE"}),", on an address not present in an access list costs more than if the address were already in the list. Other opcodes that can modify the access list include"," ",(0,d.jsx)(l.Ch,{to:"#3B",title:"EXTCODESIZE"}),","," ",(0,d.jsx)(l.Ch,{to:"#3C",title:"EXTCODECOPY"}),","," ",(0,d.jsx)(l.Ch,{to:"#3F",title:"EXTCODEHASH"}),","," ",(0,d.jsx)(l.Ch,{to:"#F1",title:"CALL"}),","," ",(0,d.jsx)(l.Ch,{to:"#F2",title:"CALLCODE"}),","," ",(0,d.jsx)(l.Ch,{to:"#F4",title:"DELEGATECALL"}),","," ",(0,d.jsx)(l.Ch,{to:"#FA",title:"STATICCALL"}),","," ",(0,d.jsx)(l.Ch,{to:"#F0",title:"CREATE"}),","," ",(0,d.jsx)(l.Ch,{to:"#F5",title:"CREATE2"})," and"," ",(0,d.jsx)(l.Ch,{to:"#FF",title:"SELFDESTRUCT"}),". Each opcode has its own cost when modifying the access set."]}),(0,d.jsxs)("p",{className:"pb-6",children:["Touch slot lists are a list of storage slot keys accessed by contract addresses. Slot lists are initialized to empty. When an opcode accesses a slot that is not present in the list, it adds it to it. Opcodes that can modify the touched slot list are"," ",(0,d.jsx)(l.Ch,{to:"#54",title:"SLOAD"})," and"," ",(0,d.jsx)(l.Ch,{to:"#55",title:"SSTORE"}),". Again, both opcodes have their own cost when modifying the access list."]}),(0,d.jsx)("p",{className:"pb-6",children:"If an address or storage slot is present in the set, it is called 'warm'; otherwise it is 'cold'. Storage slots that are touched for the first time in a transaction change from cold to warm for the duration of the transaction. Transactions can pre-specify contracts as warm using EIP-2930 access lists. The dynamic cost of some opcodes depends on whether an address or slot is warm or cold."}),(0,d.jsxs)("p",{className:"pb-8",children:["At the start of a transaction's execution, the touched addresses set is initialized to include the following addresses, which are hence always 'warm':",(0,d.jsxs)("ul",{className:"list-disc mb-2",children:[(0,d.jsx)("br",{}),(0,d.jsxs)("li",{children:["After the ",(0,d.jsx)("b",{children:"Berlin"})," hardfork: all precompiled contract addresses as well as ",(0,d.jsx)("b",{children:"tx.sender"})," and ",(0,d.jsx)("b",{children:"tx.to"})," (or the address being created if it is a contract creation transaction)."]}),(0,d.jsx)("br",{}),(0,d.jsxs)("li",{children:["After the ",(0,d.jsx)("b",{children:"Shanghai"})," hardfork: the"," ",(0,d.jsx)(l.Ch,{to:"#41",title:"COINBASE"})," address."]})]})]}),(0,d.jsx)("p",{className:"pb-6",children:"If a context is reverted, access warming effects are reverted to their state before the context."})]}),(0,d.jsx)(m,{header:(0,d.jsx)(l.H3,{children:"Gas Refunds"}),anchorKey:"gasrefunds",children:(0,d.jsxs)("p",{className:"pb-8",children:["Some opcodes can trigger gas refunds, which reduces the gas cost of a transaction. Gas refunds are applied at the end of a transaction. If a transaction has insufficient gas to reach the end of its run, its gas refund cannot be triggered, and the transaction fails. With the introduction of the ",(0,d.jsx)("b",{children:"London"})," hardfork, two aspects of gas refunds changed. First, the limit to how much gas can be refunded is lowered from half of the total transaction cost to one fifth of the total transaction cost. Second, the"," ",(0,d.jsx)(l.Ch,{to:"#FF",title:"SELFDESTRUCT"})," opcode cannot trigger gas refunds, only ",(0,d.jsx)(l.Ch,{to:"#55",title:"SSTORE"}),"."]})}),(0,d.jsxs)(m,{header:(0,d.jsx)(l.H2,{children:"Other EVM Related Resources"}),anchorKey:"otherevmresources",children:[(0,d.jsxs)("p",{className:"pb-8",children:[(0,d.jsx)("a",{href:"https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf",target:"_blank",rel:"noreferrer",className:"underline",children:"Ethereum EVM Illustrated (2018)"}),","," ",(0,d.jsx)("a",{href:"https://ethereum.org/en/history/",target:"_blank",rel:"noreferrer",className:"underline",children:"The History and Forks of Ethereum"}),","," ",(0,d.jsx)("a",{href:"https://www.youtube.com/watch?v=RxL_1AfV7N4&t=1s",target:"_blank",rel:"noreferrer",className:"underline",children:"EVM: From Solidity to bytecode, memory and storage"}),","," ",(0,d.jsx)("a",{href:"https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy",target:"_blank",rel:"noreferrer",className:"underline",children:"EVM Deep Dives by noxx"}),","," ",(0,d.jsx)("a",{href:"https://github.com/ethereumbook/ethereumbook/blob/develop/13evm.asciidoc",target:"_blank",rel:"noreferrer",className:"underline",children:"The EVM Chapter in the Mastering Ethereum book"}),","," ",(0,d.jsx)("a",{href:"https://x.com/uttam_singhk/status/1830526179105001771",target:"_blank",rel:"noreferrer",className:"underline",children:"EOF (EVM Object Format): Full Guide"})]}),(0,d.jsxs)("em",{children:[(0,d.jsxs)("p",{children:["Acknowledgment to"," ",(0,d.jsx)("a",{href:"https://github.com/wolflo/evm-opcodes",target:"_blank",rel:"noreferrer",className:"underline",children:"wolflo"})," ","for the cost descriptions."," "]}),(0,d.jsxs)("p",{children:["Check out"," ",(0,d.jsx)("a",{href:"https://blog.smlxl.io/",target:"_blank",rel:"noreferrer",className:"underline",children:"our blog"})," ","for more writeups about the EVM, and other blockchain concepts."]})]})]})]});u.getLayout=function(e){return(0,d.jsx)(c.Z,{children:e})},t.default=u},70416:function(e,t,s){"use strict";s.d(t,{C:function(){return n},V:function(){return r}});const r=navigator.userAgent.toUpperCase().indexOf("MAC")>=0,n=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";const t="https://www.evm.codes";return t+e}},54295:function(e,t,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/about",function(){return s(8768)}])}},function(e){e.O(0,[218,774,888,179],(function(){return t=54295,e(e.s=t);var t}));var t=e.O();_N_E=t}]);