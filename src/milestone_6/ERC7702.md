# EIP7702

[EIP7702](https://eips.ethereum.org/EIPS/eip-7702) 允许扩展 `EOA` 地址，。

`EOA` 地址扩展的合约 `Code` 为`(0xef0100 || address)`，因为根据[EIP3541](https://eips.ethereum.org/EIPS/eip-3541)不允许部署 0xef 开头的合约。

## GetCodes
`0xef0100` 开头的 `bytecodes` 表示当前地址是扩展的 `EOA` 地址
```go
func AccountCodes(address common.Address) string {
	res, err := client.CodeAt(context.Background(), address, nil)
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("codes: %s", hexutil.Encode(res))
	//0xef010080296ff8d1ed46f8e3c7992664d13b833504c2bb
	return hexutil.Encode(res)
}
```

因此，通过下面代码能够判断出当前地址是否是扩展的 `EOA` 地址
```solidity
bytes3 internal constant _DELEGATION_PREFIX = 0xef0100;
function isEOA(address target) internal view returns (bool) {
    bytes memory code = target.code;
    // Add here a comment addressing the normal disclaimers around
    // construction-time issues and zero-length contracts.
    return (code.length == 0 || bytes3(code) == _DELEGATION_PREFIX);
}

/**
 * @dev Returns the address of the delegate if `account` as an EIP-7702 delegation setup, or address(0) otherwise.
     */
function fetchDelegate(address account) internal view returns (address) {
    bytes23 delegation = bytes23(account.code);
    return bytes3(delegation) == EIP7702_PREFIX ? address(bytes20(delegation << 24)) : address(0);
}
```

合约验签：
```solidity
abstract contract SignerERC7702 is AbstractSigner {
    /**
     * @dev Validates the signature using the EOA's address (i.e. `address(this)`).
     */
    function _rawSignatureValidation(
        bytes32 hash,
        bytes calldata signature
    ) internal view virtual override returns (bool) {
        (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);
        return address(this) == recovered && err == ECDSA.RecoverError.NoError;
    }
}
```

## OKX WalletCore
`OKX` 钱包升级升级 `7702` 后，地址存在三种类型交易

### executeFromSelf
`EOA` 地址自己调用，在 `transfer_To_Self` 交易的同时附加上 `calldata`，底层逻辑会自动匹配合约函数执行
```solidity
    modifier onlySelf() {
        if (msg.sender != address(this)) revert Errors.NotFromSelf();
        _;
    }
    
    function executeFromSelf(Call[] calldata calls) external onlySelf {
        _batchCall(calls);
    }
```
### executeWithValidator
`Validator` 发送交易，其中 `Validator` 可以是 `EOA` 本身或者时 `EOA` 地址指定的白名单地址

允许外部地址代付 `Gas`,外部地址被设置为白名单后或者直接使用 `EOA_Self` 的签名执行批量操作

函数需要验签，通过自增的 `nonce` 保证签名单次使用

- Validator == address(1),
  - 表示 `Validator` 是 `EOA Self`，要求 `signer == EOA `
- Validator 是其余白名单地址时，要求签名满足 Validator 合约的内部逻辑
  - `try IValidator(validator).validate(typedDataHash, validationData)`
  - 如果 `Validator` 被设置成纯 `EOA` 地址的话，底层 `call` 调用将永远会返回 `true`,也就是将会绕过签名校验的流程
  - 这就需要 `EOA-7702` 谨慎设置 `validator` 白名单

```solidity
    function executeWithValidator(
        Call[] calldata calls,
        address validator,
        bytes calldata validationData
    ) external onlyValidator(calls, validator, validationData) {
        _batchCall(calls);
    }
```
### executeFromExecutor
在 `executeWithValidator` 基础功能上继续扩展数据结构，增加 `Session` 结构体限制交易
```solidity
struct Session {
    uint256 id;
    address executor;
    address validator;
    uint256 validUntil;
    uint256 validAfter;
    bytes preHook;
    bytes postHook;
    bytes signature;
}
```
整个 `Session` 结构和批量转账数据会执行 `Validator` 的验签流程

该交易只允许由 `Executor` 执行，该地址被放置在签名结构体中。

此外，交易还能设置有效期、`Hook` 功能校验等
```solidity
    function validateSession(Session calldata session) public view {
        // Check executor authorization
        if (msg.sender != session.executor) revert Errors.InvalidExecutor();

        // Check time bounds
        if (
            session.validAfter > block.timestamp ||
            block.timestamp > session.validUntil
        ) revert Errors.InvalidSession();

        // Check invalidSessionId & validValidator in storage
        getMainStorage().validateSession(session.id, session.validator);

        // Validate signature
        bytes32 hash = getSessionTypedHash(session);
        bool isValid = WalletCoreLib.validate(
            session.validator,
            hash,
            session.signature
        );
        if (!isValid) revert Errors.InvalidSignature();
    }
```

## Preference
[https://github.com/okx/wallet-core](https://github.com/okx/wallet-core)

[https://ethereum.org/roadmap/pectra/7702](https://ethereum.org/roadmap/pectra/7702)

[https://eips.ethereum.org/EIPS/eip-7702]https://eips.ethereum.org/EIPS/eip-7702

[https://etherscan.io/tx/0xebc6f503d3c7cf9560308c8efef69a6c4a993a29224d7a4a4f13ca98d6ae0621](https://etherscan.io/tx/0xebc6f503d3c7cf9560308c8efef69a6c4a993a29224d7a4a4f13ca98d6ae0621)

[https://www.certik.com/zh-CN/resources/blog/pectras-eip-7702-redefining-trust-assumptions-of-externally-owned-accounts](https://www.certik.com/zh-CN/resources/blog/pectras-eip-7702-redefining-trust-assumptions-of-externally-owned-accounts)